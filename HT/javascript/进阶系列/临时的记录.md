## 语法

### 语句和表达式

JavaScript 的语法。语句相当于句子，表达式相当于短语，运算符则相当于标点符号和连接词

JavaScript  中表达式可以返回一个结果值

```js
var a = 3 * 6;
var b = a;
b;
```

 3 * 6 是一个表达式（结果为 18 ）, 第二行的 a 也是一个表达式 , 第三行的 b 也是。

var a = 3 * 6 和 var b = a 称为 “ 声明语句 ” （ declaration statement ）,  a = 3 * 6 和 b = a （不带 var ）叫作 “ 赋值表达式 ” 。

第三行代码中只有一个表达式 b ，同时它也是一个语句（虽然没有太大意义）。这样的情况通常叫作 “ 表达式语句 ” （ expressionstatement ）。

**语句的结果**

在控制台中输入 var a = 42 会得到结果值 undefined ，而非 42 。控制台中显示的就是语句的结果值。

ES5  规范 12.2  节中的变量声明（ VariableDeclaration ）算法实际上有一个返回值（是一个包含所声明变量名称的字符串，很奇特吧？），但是这个值被变量语句（ VariableStatement ）算法屏蔽掉了（ for..in 循环除外），最后返回结果为空（ undefined ）

代码块 { .. } 的结果值是其最后一个语句 /  表达式的结果

```js
var b;
if (true) {
  b = 4 + 38;
  var a = b;
}

// 42
```

**如何获得语句的结果值并将其赋值给另一个变量。(目前是不行的)**

那应该怎样获得语句的结果值呢？

-  eval(..) 

    ```js
    var a, b;
    a = eval( "if (true) { b = 4 + 38; }" );
    a; // 42
    ```

    这并不是个好办法，但确实管用

- ES7  规范有一项 “do  表达式 ” （ do expression ）提案

    ```js
    var a, b;
    a = do {
            if (true) {
                b = 4 + 38;
            }
        };
        a; // 42
    ```

    上例中， do { .. } 表达式执行一个代码块（包含一个或多个语句），并且返回其中最后一个语句的结果值，然后赋值给变量 a 。

    其目的是将语句当作表达式来处理（语句中可以包含其他语句），从而不需要将语句封装为函数再调用 return 来返回值。

### 表达式副作用

最常见的有副作用（也可能没有）的表达式是函数调用：

```js
function foo() {
    a = a + 1;
}
var a = 1;
foo(); //  结果值： undefined 。副作用： a 的值被改变
```

其他一些表达式也有副作用，比如：

```js
var a = 42;
var b = a++;

a; // 43
b; // 42
```

a++ 首先返回变量 a 的当前值 42 （再将该值赋给 b ），然后将 a 的值加 1

++a++ 会产生 ReferenceError 错误，因为运算符需要将产生的副作用赋值给一个变量。以 ++a++ 为例，它首先执行 a++ （根据运算符优先级），返回 42 ，然后执行 ++42 ，这时会产生ReferenceError 错误，因为 ++ 无法直接在 42 这样的值上产生副作用。

逗号运算符（ statement-series comma operator ）将多个独立的表达式语句串联成一个语句：

```js
var a = 42, b;
b = ( a++, a );
a; // 43
b; // 43
```

###  = 赋值运算符

```js
var a;
a = 42; // 42
a; // 42
```

a = 42 中的 = 运算符看起来没有副作用，实际上它的结果值是 42 ，它的副作用是将 42 赋值给 a 。

多个赋值语句串联时（链式赋值， chained assignment ），赋值表达式（和语句）的结果值就能派上用场

```js
var a, b, c;
a = b = c = 42;
```

这里 c = 42 的结果值为 42 （副作用是将 c 赋值 42 ），然后 b = 42 的结果值为 42 （副作用是将 b 赋值 42 ），最后是a = 42 （副作用是将 a 赋值 42 ）。

**注意**

var a = b = 42 ，看似和前面的例子差不多，实则不然。如果变量 b 没有在作用域中象 var b 这样声明过，则 var a = b = 42 不会对变量 b 进行声明。在严格模式中这样会产生错误，或者会无意中创建一个全局变量

### 上下文规则

在 JavaScript  语法规则中，有时候同样的语法在不同的情况下会有不同的解释。

看下面的代码

```js
var a = {
  foo : bar()
}
```

如果当我们吧var a = 去掉

```js
{
  foo : bar()
}
```

很多人认为{...}是一个孤立的对象常量，没有被赋值，其实不然，{...}在这里只是一个普通的代码快。{...}和if、while、for循环中的{}基本相同。

但是 foo : bar(); 这样的语法就有点奇怪了。

**标签**

这里涉及 JavaScript  中一个不太为人知（也不建议使用）的特性，叫作 “ 标签语句 ” （ labeled statement ）。

foo 是语句 bar() 的标签（后面没有 ;）。

JavaScript  通过标签跳转能够实现 goto 的部分功能。 continue 和 break 语句都可以带一个标签，因此能够像 goto那样进行跳转。例如：

```js
//  标签为 foo 的循环
foo: for (var i = 0; i < 4; i++) {
    for (var j = 0; j < 4; j++) {
        //  如果 j 和 i 相等，继续外层循环
        if (j == i) {
            //  跳转到 foo 的下一个循环
            continue foo;
        }
        //  跳过奇数结果
        if ((j * i) % 2 == 1) {
            //  继续内层循环（没有标签的）
            continue;
        }
        console.log(i, j);
    }
}
// 1 0
// 2 0
// 2 1
// 3 0
// 3 2
```

contine foo 并不是指 “ 跳转到标签foo 所在位置继续执行 ” ，而是 “ 执行 foo 循环的下一轮循环 ” 。所以这里的 foo 并非 goto 。

带标签的循环跳转一个更大的用处在于，和 break 一起使用可以实现从内层循环跳转到外层循环。

```js
//  标签为 foo 的循环
foo: for (var i = 0; i < 4; i++) {
    for (var j = 0; j < 4; j++) {
        if ((i * j) >= 3) {
            console.log("stopping!", i, j);
            break foo;
        }
        console.log(i, j);
    }
}
// 0 0
// 0 1
// 0 2
// 0 3
// 1 0
// 1 1
// 1 2
//  停止！ 1 3
```

break foo 不是指 “ 跳转到标签 foo 所在位置继续执行 ” ，而是 “ 跳出标签 foo 所在的循环 /  代码块，继续执行后面的代码 ” 。

JSON  被普遍认为是 JavaScript  语言的一个真子集， {"a":42} 这样的 JSON  字符串会被当作合法的 JavaScript  代码（请注意JSON  属性名必须使用双引号！）。其实不是！如果在控制台中输入 {"a":42} 会报错。

因为标签不允许使用双引号，所以 "a" 并不是一个合法的标签，因此后面不能带 : 。

JSON  的确是 JavaScript  语法的一个子集，但是 JSON  本身并不是合法的 JavaScript  语法。

**JSON-P能将JSON转换为合法的JavaScript语法**

常被提到的一个坑

```js
[] + {}; // "[object Object]"
{} + []; // 0
```

表面上看 + 运算符根据第一个操作数（ [] 或 {} ）的不同会产生不同的结果，实则不然。

第一行代码中， {} 出现在 + 运算符表达式中，因此它被当作一个值（空对象）来处理。 [] 会被强制类型转换为"" ，而 {} 会被强制类型转换为 "[object Object]" 。

但在第二行代码中， {} 被当作一个独立的空代码块（不执行任何操作）。代码块结尾不需要分号，所以这里不存在语法上的问题。最后 + [] 将 [] 显式强制类型转换为 0
