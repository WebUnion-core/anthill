# 散列(hash)

散列是一种常用的数据存储技术，散列后的数据可以快速地插入或取用。

下图 以一个小型电话号码簿为例，阐释了散列的概念

![](https://upload-images.jianshu.io/upload_images/8812203-910bb6d29c03568a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


## 定义散列类 

```js
class HashTable {
    constructor() {
        this.table = new Array(137);
    }
}
```

## 选择一个散列函数

散列函数的选择依赖于键值的数据类型，如果键是整型，最简单的散列函数就是以数组的长度对键取余。在一些情况下，比如数组的长度是 10，而键值都是 10 的倍数时，就不推荐使用这种方式了。这也是数组的长度为什么要是质数的原因之一，就像我们在上个构造函数中，设定数组长度为 137 一样。如果键是随机的整数，则散列函数应该更均匀地分布这些键。这种散列方式称为**除留余数法**。

将字符串中每个字符的 ASCII 码值相加似乎是一个不错的散列函数。这样散列值就是 ASCII 码值的和除以数组长度的余数。

put() 和 showDistro() ，一个用来将数据存入散列表，一个用来显示散列表中的数据

```js
class HashTable {
    constructor() {
        this.table = new Array(137);
    }

    simpleHash(data) {
        let total = 0;
        for (let i = 0; i < data.length; i++) {
            total += data.charCodeAt(i);
        }

        return total % this.table.length;
    }
    put(data) {
        let pos = this.simpleHash(data);
        this.table[pos] = data;
    }

    showDistro() {
        for (let i in this.table) {
            if(this.table[i] != undefined) {
                console.log(`${i} : ${this.table[i]}`);
            }
        }
    }
}

let ht = new HashTable();

let names = ["David", "Jennifer", "Donnie", "Raymond","Cynthia", "Mike", "Clayton", "Danny", "Jonathan"];

for(let i in names) {
    ht.put(names[i]);
}

ht.showDistro();
/*
35 : Cynthia
45 : Clayton
57 : Donnie
77 : David
95 : Danny
116 : Mike
132 : Jennifer
134 : Jonathan
*/
```

很显然，数据并不是均匀分布的，人名向数组的两端集中。而且上面打印出来的只有8个，可是我们的names里有9个名字，这就是碰撞的问题，什么时候发生了碰撞呢。往下看

```js
simpleHash(data) {
    let total = 0;
    for (let i = 0; i < data.length; i++) {
        total += data.charCodeAt(i);
    }
    console.log('hash 列表 :' + data + "---->" + total)
    return total % this.table.length;
}

// 打印结果

/*
hash 列表 :David---->488
hash 列表 :Jennifer---->817
hash 列表 :Donnie---->605
hash 列表 :Raymond---->730
hash 列表 :Cynthia---->720
hash 列表 :Mike---->390
hash 列表 :Clayton---->730
hash 列表 :Danny---->506
hash 列表 :Jonathan---->819
*/
```

我们发现 经过hash算法转换过的 Clayton 和 Raymond 都是730  这就发生了碰撞的问题，所以Clayton会将 Raymond给覆盖了。

## 一个更好的散列函数

为了避免碰撞，首先要确保散列表中用来存储数据的数组其大小是个质数。这一点很关键，这和计算散列值时使用的取余运算有关。

为了避免碰撞，在给散列表一个合适的大小后，接下来要有一个计算散列值的更好方法。霍纳算法很好地解决了这个问题。在此算法中，新的散列函数仍然先计算字符串中各字符的 ASCII 码值，不过求和时每次要乘以一个质数。大多数算法书建议使用一个较小的质数

```js
betterHash(string) {
    const H = 37;
    var total = 0;
    for (var i = 0; i < string.length; ++i) {
        total += H * total + string.charCodeAt(i);
    }
    total = total % this.table.length;
    if (total < 0) {
        total += this.table.length - 1;
    }
    return parseInt(total);
}
```

这次所有的人名都显示出来了，而且没有碰撞

## 散列化整型键

此处介绍如何散列化整型键，使用的数据集是学生的成绩。我们将随机产生一个 9 位数的键，用以识别学生身份和一门成绩。下面是产生学生数据（包含 ID 和成绩）的函数：

```js
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function genStuData(arr) {
    for (var i = 0; i < arr.length; ++i) {
        var num = "";
        for (var j = 1; j <= 9; ++j) {
            num += Math.floor(Math.random() * 10);
        }
        num += getRandomInt(50, 100);
        arr[i] = num;
    }
}
```

使用 getRandomInt() 函数时，可以指定随机数的最大值和最小值。拿学生的成绩来说，最低分是 50，最高分是 100。

genStuData() 函数生成学生的数据。里层的循环用来生成学生的 ID，紧跟在循环后面的代码生成一个随机的成绩，并把成绩缀在 ID 的后面。主程序会把 ID 和成绩分离。散列函数将学生 ID 里的数字相加，使用 simpleHash() 函数计算出散列值。

