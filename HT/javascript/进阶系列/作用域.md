## 编译原理

- 分词/词法分析

    这个过程称为分解代码块(词法单元)，比如 var a = 2;。这个程序通常会被分解成为下面这些代码块(词法单元): var、a、=、2、;一般情况下空格不会被当作词法单元。

- 解析\语法分析

    将词法单元数组转化成语法结构树"抽象语法树(AST)"。

- 代码生成

    将AST转换成可执行代码的过程被成为代码生成。就是将一段我们看得懂的代码转化成机器指令。

JavaScript的编译过程不是发生在构建之前的，大部分情况下发生在代码执行钱的几微秒。任何JavaScript代码片在执行之前都要进行编译，因此，JavaScript编译器首先会对var a = 2;这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。

## 什么是作用域

就是能够储存变量当中的值，并且能再之后地这个值进行访问或修改。是一套设计良好的用来储存变量的规则。并且之后可以方便的访问到这些变量。这套规则就成为作用域。

### 如何工作

- 引擎
    负责整个JavaScript程序的编译及执行过程

- 编译器
    负责语法分析及代码生成。

- 作用域
    收集维护所有声明的标识符(变量)组成的一系列查询，并实施一套严格的规则，确定当前执行的代码对这些标识符的访问权限。

### 工作过程

针对var a = 2;这一段代码来看，引擎会认为这里有两个不同的声明，一个是在编译器在编译的时候处理，另一个是引擎在运行的时候处理的。

首先是编译器进行处理:

**1.**遇到var a,编译器会询问作用域是否已经有一个该名称的变量存在与同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译;否则它会要求作用域在当前作用域的集合中声明一个心的变量，命名为a。

**2.**接下来编译器回味引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行的时候首先询问作用域，在当前的作用域几何中是否存在一个叫做a的变量，如果是，引擎就会使用这个变量；如果不存在这个变量，引擎就会继续查找这个变量，向上查找。之后会讲到如何向上查找

向上查找结束后如果找到了a变量就会将2赋值给它，否则一般情况下就会抛出一个错误(浏览器中需要严格模式)，浏览器环境中非严格模式会在全局创建一个a变量。

### LHS查询和RHS查询

可以理解成左查询和右查询。赋值操作的左右侧查询(不完全正确)

换句话说，当变量出现在赋值操作的左侧的时候进行LHS查询，出现在非左侧的时候进行RHS查询。更准确的说法就是，RHS查询就相当于是查找某个变量的值，而LHS查询则是是u找到变量的容器本身，从而可以对其赋值。

如下代码:

```js

console.log(a)
```
其中这里对a是一个RHS引用，因为这里是要查找a的值，而不是查找a容器而去赋值给a。

```js

a = 2
```
相比如上的代码，这里不用去关心当前的值是什么，我们只要把 = 2 这个赋值操作找到一个目标。

再继续深入：

```js

function foo(a) {
    console.log( a ); //2
}

foo(2)
```
上面的代码中，存在的一个隐式操作，当2被当作参数传递给foo(..)函数时会进行一次a = 2的赋值操作。所以这里需要进行一次LHS查询。当执行到console.log(a)的时候，这里引擎需要console这个对象进行RHS，并且检查得到的值中是否有一个叫做log的方法。log(..)函数再执行的时候假设log函数实现中接受参数，这个参数也需要进行LHS引用。

看如下代码：

```js

function foo(a) {
    var b = a;
    return a + b;
}

var c = foo(2);
```
上面的代码中，首先var c = foo(2),会进行一次LHS查询 c 容器。然后回对foo进行一次RHS查询，然后执行foo(2)对函数里的a进行一次LHS查询，然后var b = a;中，对b进行一次LHS查询，对a进行一次RHS查询，然后return a + b; 进行一次对a的RHS查询，进行一次对b的RHS查询。

所以这里这段代码进行了三次LHS查询，四次RHS查询。


### 作用域嵌套

当一个快或函数嵌套再另一个快或者函数中时，就发生了作用域的嵌套。

在当前作用域中如果无法找打某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或者一直找到最外层作用域为止。

看以下代码:
```js

var a = 22;

function geta() {
    console.log(a)
}
```

对a进行的RHS查询无法在函数geta中完成，但是可以在上一级作用域中完成。

----

## 词法作用域

词法作用域就是定义在词法阶段的作用域，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变

```js

function foo(a) {
    var b = a * 2;

    function bar(c) {
        console.log( a, b, c );
    }

    bar( b * 3);
}

foo(2); // 2, 4, 12
```
这个例子中有三个逐级嵌套的作用域。如下图

![Alt text](https://coding.net/u/hong_tao/p/my_study/git/raw/master/HT/imgs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B5%8C%E5%A5%97.png "UML类图")

- 全局作用域 ： foo
- foo的作用域 : a ,bar ,b
- bar的作用域 : c

### 查找

在上一段代码中，引擎执行console.log(a ,b ,c)，查找a,b,c三个变量的引用。首先是从最内部的bar作用域开始查找，引擎无法在这里找到a，因此会到上一级的foo中查找，再找不到会到全局作用域中查找。

作用域查找会在找到匹配的标识符之后停止。

多层嵌套作用域中定义同名的标识符，就照成了"屏蔽效应"。


----

## 函数作用域和块作用域

### 函数中的作用域

```js

function foo(a) {
    var b = 2;
    function bar(){

    }
    var c = 3;
}
```

在这个代码片段中，foo和bar都拥有着自己的作用域气泡。全局也包含着foo标识符。

a,b,bar,都属于foo的作用域气泡，无法从foo的外部去访问。比如

```js

bar(); //error
console.log(a,b,c); // error
```

内层是可以访问外层的。