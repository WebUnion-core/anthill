直接看下面这段代码

```js
function ooo(name) {
    this.name = name;
    return name
}


console.log(new ooo('222'))

function ooo2(name) {
    this.name = name;
    return [1,2,3,4]
}


console.log(new ooo2('444'))
```

输出的是

```js
'ooo {name: "222"}'
'Array(4) [1, 2, 3, 4]'
```

## JavaScript对象的创建方式

首先我们了解一下js中对象的创建方式

在JavaScript中，创建对象的方式包括两种：对象字面量和使用new表达式。对象字面量是一种灵活方便的书写方式，例如：

```js
var o = {
    name : '洪涛'
}
```

new表达式是配合构造函数使用的:

```js
function O(name){
    this.name = name;
}

var o = new O('洪涛');
```

那么，在使用new操作符来调用一个构造函数的时候，发生了什么呢？其实很简单，就发生了四件事：

```js
var obj  ={};
obj.__proto__ = CO.prototype;
CO.call(obj);
return obj;
```

- 第一行，创建一个空对象obj。

- 第二行，将这个空对象的__proto__成员指向了构造函数对象的prototype成员对象，这是最关键的一步。

- 第三行，将构造函数的作用域赋给新对象，因此CA函数中的this指向新对象obj，然后再调用CO函数。于是我们就给obj对象赋值了一个成员变量name，这个成员变量的值是"洪涛"。

- 第四行，返回新对象obj。

> 第四部就是我们需要注意的地方，构造器中如果包含返回值。

## 正确的定义构造函数

如果没有按照正确的方法书写构造函数的话，就像本文上文中出现的情况。就会造成一些难以估计的后果。

一个函数，要做为一个真正意义上的构造函数，要满足以下条件。

- 1、 在函数内部对新对象（this）的属性进行设置，通常是添加属性和方法。
- 2、 构造函数可以包含返回语句（不推荐），但返回值必须是this，或者其它非对象类型的值。

如上文中 我们的构造函数中返回了参数name,如果参数是普通值(非引用类型)，则不会发生什么影响，但是如果值是引用类型（如对象，数组等），则我们new 出来的对象就会被返回的引用类型值给替换了。

**可以看出：在JavaScript构造函数中：如果return值类型，那么对构造函数没有影响，实例化对象返回空对象；如果return引用类型（数组，函数，对象），那么实例化对象就会返回该引用类型；**