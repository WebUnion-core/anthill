
# 深入浅出Node.js十一日探(三) #

## 目录 ##

1. [为什么要异步I/O](#href1)
    1. [用户体验](#href1-1)
    2. [资源分配](#href1-2)
2. [Node.js的异步I/O](#href2)
    1. [事件循环](#href2-3)
    2. [观察者](#href2-4)
    3. [请求对象](#href2-5)
3. [非I/O的异步API](#href3)
4. [事件驱动与高性能服务器](#href4)

## <a name="href1">为什么要异步I/O</a> ##

### <a name="href1-1">用户体验</a> ###

异步最先是在 Web2.0 中火起来的，因为在浏览器中 JavaScript 在单线程上执行，它与 UI 渲染共用一个线程。如果网页同步获取一个网络资源，那么 JavaScript 需要等待资源完全从服务器端获取后才能继续执行，这期间 UI 将停顿，不影响用户的交互行为，这样的用户体验是很差的; 但是使用异步请求则不同，在异步下载资源期间，JavaScript 和 UI 都不会被资源阻塞，仍可以继续响应用户的交互行为，用户体验大大提升。

前端通过异步可以消除 UI 阻塞，同样也可以异步请求后端接口，每个接口相互独立，请求互不阻塞，这就是并发，并发使得后端能够快速响应资源，后端响应更快，前端的体验也就更好。

### <a name="href1-2">资源分配</a> ###

首先讲下多线程编程模型与单线程同步编程模型的资源分配:

多线程编程模型的优点是在多核 CPU 上能够有效提升 CPU 的利用率，其(并行)缺点是在创建线程和执行期线程上下文切换的开销较大，而且在复杂的业务中，多线程编程经常面临锁、状态同步等问题，这是多线程被诟病的主要原因。

单线程同步编程模型的优点是易于表达，其执行任务的方式比较符合编程人员按顺序思考的思维方式，其(串行)缺点在于性能，任意一个略慢的任务都会导致后续代码被阻塞，而且还无法利用多核 CPU。

结合这两种编程模型的特点，Node.js 设计出了一种独特的方案: 利用单线程，远离多线程死锁、状态同步等问题; 利用异步 I/O 让单线程远离阻塞，以更好地使用 CPU。

也许有人认为，Node.js 使用了单线程就无法利用多核 CPU，Node.js 也给出了解决这个问题的方案，那就是使用"子进程"，以后会详细讲解"子进程"。

## <a name="href2">Node.js的异步I/O</a> ##

### <a name="href2-3">事件循环</a> ###

Node.js 自身的执行模型——事件循环，使得 Node.js 中回调函数十分普遍。在进程启动时，Node.js 便会创建一个类似`while(true)`的循环，每执行一次循环体的过程就会查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们，然后进入下个循环，如果不再有事件处理，就退出进程。

### <a name="href2-4">观察者</a> ###

每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。浏览器也采用了类似的机制，事件来自用户的点击或者其他操作，这些产生的事件都有对应的观察者。在 Node.js 中，事件主要来源于网络请求、文件 I/O 等，这些事件对应的观察者有文件 I/O 观察者、网络 I/O 观察者等。观察者将事件进行了分类。

事件循环是一个典型的生产者/消费者模型。异步 I/O、网络请求等则是事件的生产者，源源不断为 Node.js 提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。

### <a name="href2-5">请求对象</a> ###

Node.js 的异步 I/O 调用中，回调函数并不是由开发者调用，回调函数的执行离不开请求对象，请求对象是在 JavaScript 发起调用到内核执行完 I/O 操作的过渡过程中产生的中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及 I/O 操作完毕后的回调处理等。

以 Node.js 中常见的异步操作文件为例，首先通过 JavaScript 调用 Node.js 中的核心模块，然后核心模块调用 C++ 内建模块，内建模块通过 libuv 进行系统调用(libuv 作为封装层，有两个平台的实现)，接着就包装出了一个请求对象，我们传入的回调函数就附加在这个请求对象上，最后推入线程池中等待执行，最后等回调执行完毕，线程池会回发消息进行回调通知，至此，整个异步 I/O 的流程完全结束了。

## <a name="href3">非I/O的异步API</a> ##

Node.js 中存在一些与 I/O 无关的异步 API，它们分别是`setTimeout()`、`setInterval()`、`setImmediate()`和`process.nextTick()`，后两者的内容可以自行查阅资料，这里着重介绍下`setTimeout()`和`setInterval()`。

`setTimeout()`和`setInterval()`与浏览器中的 API 是一致的，分别用于单次和多次定时执行任务。它们的实现原理与异步 I/O 比较类似，只是不需要 I/O 线程池的参与。调用这两个方法创建的定时器会被插入到定时器观察者内部的一个红黑树中，每次定时器触发，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。

定时器的问题在于，它并非精确的。尽管事件循环非常的快，但是如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时很久了。譬如通过`setTimeout()`设定一个任务在10毫秒后执行，但是在9毫秒后，有一个任务占用了5毫秒的 CPU 时间片，再次轮到定时器执行时，时间已经过期4毫秒

## <a name="href4">事件驱动与高性能服务器</a> ##

前面介绍了异步的实现原理，从中可以看出事件驱动的实质就是通过主循环加事件触发的方式来运行程序。在异步 I/O 调用中，如果 JavaScript 有传入回调函数，这些事件将会最终传递到业务逻辑层进行处理。利用 Node.js 构建 Web 服务器，正是在这样一个基础上实现的，接下来先介绍下几种经典的服务器模型:

1. 同步式: 对于同步式的服务，一次只能处理一个请求，并且其余请求都处于等待状态;
2. 每进程/每请求: 为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，毕竟系统资源是有限的;
3. 每线程/每请求: 为每个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定的内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢，每线程/每请求的扩展性比每进程/每请求的方式要好，但对于大型站点而言依然不够。

Node.js 不同于以上几种模型，它通过事件驱动的方式处理请求，无须为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价很低。这使得服务器能够有条不紊地处理请求，即使在大量连接地情况下，也不受线程上下文切换开销的影响，这是 Node.js 高性能的一个原因。

大名鼎鼎的 Nginx 服务器也摒弃了多线程的方式，采用了和 Node.js 相同的事件驱动机制，如今，Nginx 大有取代 Apache 之势。Node.js 具有与 Nginx 相同的特性，不同之处在于 Nginx 是用C语言写的，性能较高，但是它仅适合于 Web 服务器，用于反向代理或负载均衡等服务，在处理具体业务方面较为欠缺。Node.js 则是一套高性能的平台，可以利用它构建与 Nginx 相同的功能，也可以处理各种具体业务，而且与背后的网络保持异步畅通。两者相比，Node.js 没有 Nginx 在 Web 服务器方面那么专业，但场景更大，自身性能也不错。

---

```
ID         : 129
DATE       : 2019/04/07
AUTHER     : WJT20
TAG        : Node.js
```
