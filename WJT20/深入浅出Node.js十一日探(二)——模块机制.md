
# 深入浅出Node.js十一日探(二)——模块机制 #

## 目录 ##

1. [模块的历史](#href1)
2. [CommonJS规范](#href2)
    1. [出发点](#href2-1)
    2. [模块规范](#href2-2)
3. [Node.js的模块实现](#href3)
    1. [优先从缓存加载](#href3-3)
    2. [路径分析与文件定位](#href3-4)
    3. [模块编译](#href3-5)
4. [包与NPM](#href4)
    1. [包结构](#href4-6)
    2. [包描述文件与NPM](#href4-7)
5. [前后端共用模块](#href5)

## <a name="href1">模块的历史</a> ##

JavaScript 先天就缺乏一项功能——模块。在其他语言中，Java 有类文件、Python 有 import 机制，Ruby 有 require，PHP 有 include 和 require。相比之下，JavaScript 就要 low 得多，它通过 script 标签引入代码，这种方式显得杂乱无章，语言自身毫无组织和约束能力，人们不得不用命名空间等方式人为地约束代码，以求达到安全和易用的目的。

社区开发者一直在努力改变 JavaScript 这种编程现状。经历了十多年的时间，社区为 JavaScript 制定了许多相应的规范，其中 CommonJS 规范的提出算是最为重要的里程碑。

## <a name="href2">CommonJS规范</a> ##

### <a name="href2-1">出发点</a> ###

在 Web 发展的过程中，JavaScript 的规范一直都很薄弱，主要缺陷有以下这些:

1. 没有模块系统;
2. 标准库较少;
3. 没有标准接口;
4. 缺乏包管理系统。

CommonJS 的提出，主要是为了弥补当前 JavaScript 没有标准的缺陷，以达到像 Python、Ruby 和 Java 具备开发大型应用的基础能力，而不是停留在小脚本程序的阶段。他们期望那些使用 CommonJS API 写出的应用可以具备跨宿主环境执行的能力，这样使得 JavaScript 既可以编写客户端应用，又可以编写以下类型的应用:

1. 服务器端 JavaScript 应用程序;
2. 命令行工具;
3. 桌面图形界面应用程序;
4. 混合应用。

目前 CommonJS 依旧在成长中，它涵盖了模块、二进制、Buffer、字符集编码、I/O 流、进程环境、文件系统、套接字、单元测试、Web 服务器网关接口、包管理等。

### <a name="href2-2">模块规范</a> ###

CommonJS 对模块的定义主要分为模块引用、模块定义和模块标识三个部分。

CommonJS 规范中的`require()`方法用于接收模块标识，以此引入一个模块的 API 到当前上下文:

```js
var fs = require('fs');
```

对应引入的功能，上下文提供了 exports 对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个 module 对象，它代表模块自身，而 exports 是 module 的属性。在 Node.js 中，一个文件就是一个模块，将方法挂载在 exports 对象上作为属性即可定义导出的方式:

getip.js 模块:

```js
var os = require('os');

module.exports = function () {
    var networkInfo = JSON.stringify(os.networkInterfaces());
    var ipArr = networkInfo.match(/"address":"[0-9]{0,3}(\.[0-9]{0,3}){3}"/g);
    var host;

    for (let i = 0; i < ipArr.length; i++) {
        var e = ipArr[i];
        var s = e.substr(11, e.length - 12);

        if (s !== '127.0.0.1') {
            host = s;
            break;
        }
    }

    return host;
}
```

config.js 模块:

```js
exports.port = 8080;
```

app.js 主模块:

```js
var config = require('config');
var getip = require('getip');
console.log('Server address: ', getip() + ':' + config.port);
```

模块标识其实就是传递给`require()`方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。它可以没有文件后缀名.js。

CommonJS 构建的这套模块导出和引入机制使得用户完全不必考虑变量污染，命名空间等方案与之相比相形见绌。

## <a name="href3">Node.js的模块实现</a> ##

在 Node.js 中引入模块，需要经历如下三个步骤:

1. 路径分析;
2. 文件定位;
3. 编译执行。

Node 模块分为两类:

1. 核心模块: 由 Node.js 提供的模块，在 Node.js 源代码的编译过程中一起被编译进了二进制执行文件，在 Node.js 进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的;
2. 文件模块: 由用户编写的模块，在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。

### <a name="href3-3">优先从缓存加载</a> ###

与前端浏览器会缓存静态脚本文件以提高性能一样，Node.js 对引入过的模块会进行缓存，以减少二次引入时的开销。不同的是，浏览器仅仅缓存文件，而 Node.js 缓存的是编译和执行之后的对象。不论是核心模块还是文件模块，`require()`方法对相同模块的二次加载都一律采用缓存优先的方式。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。

### <a name="href3-4">路径分析与文件定位</a> ###

因为标识符有几种形式，对于不同的标识符，模块的查找和定位有不同程度上的差异。

核心模块的优先级仅次于缓存加载，其加载速度最快; 其次是路径形式的文件模块，由于文件模块给 Node.js 指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块; 自定义模块(指的是非核心模块，也不是路径形式的标识符)的查找是最费时的，是所有方式中最慢的一种。

模块路径是 Node.js 在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组，可以通过访问`module.paths`获取。模块路径的生成规则是由里到外，即当前文件目录下的 node_modules 目录，接着是父目录下的  node_modules 目录，然后是父目录的父目录下的 node_modules 目录，以此类推。在加载过程中，Node.js 会逐个尝试模块路径中的路径，直到找到目标文件为止，由此看出，当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度最慢的原因。

文件定位的过程包含几个主要细节: 文件扩展名分析、目录和包的处理。

假如`require()`的标识符中不含扩展名，这时 Node.js 会按.js、.json、.node的次序补足扩展名，依次尝试。

`require()`分析文件扩展名之后，拿到的可能是一个目录，此时 Node.js 会将目录当作一个包处理。接下来，Node.js 在当前目录下查找 package.json，通过`JSON.parse()`解析对象，从中取出 main 属性指定的文件名进行定位，而如果 main 属性指定的文件名错误，或者压根没有 package.json 文件，Node.js 会将 index 当作默认文件名，然后依次查找 index.js、index.json、index.node，如果还是找不到目标文件，则继续下一文件目录查找。

### <a name="href3-5">模块编译</a> ###

编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node.js 会新建一个模块对象，然后根据路径载入并编译。不同的文件扩展名，载入的方法也有所不同，规则如下:

1. .js文件: 通过 fs 模块同步读取文件后编译执行;
2. .node文件(用 C/C++ 编写的扩展文件): 通过`dlopen()`方法加载最后编译生成的文件;
3. .json文件: 通过 fs 模块同步读取文件后，用`JSON.parse()`解析返回结果;
4. 其余扩展名文件: 当作.js文件载入。

## <a name="href4">包与NPM</a> ##

在模块之外，包和 NPM 是将模块联系起来的另一种机制。

### <a name="href4-6">包结构</a> ###

包实际上是一个存档文件，即一个目录直接打包为.zip或者tar.gz格式的文件，安装后解压还原为目录。完全符合 CommonJS 规范的包目录应该包含以下文件:

1. package.json: 包描述文件;
2. bin: 用于存放可执行文件的目录;
3. lib: 用于存放 JavaScript 代码的目录;
4. doc: 用于存放文档的目录;
5. test: 用于存放单元测试用例的代码。

### <a name="href4-7">包描述文件与NPM</a> ###

NPM 的所有行为都与包描述文件(package.json)的字段息息相关。在包描述文件的规范中，NPM 实际需要的字段有以下这些:

1. name: 包名，必须由小写字母与数字组成，可以包含.、\_和-，包名必须是唯一的;
2. description: 包简介;
3. version: 版本号，用于版本控制;
4. keywords: 关键词数组;
5. repositories: 托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码;
6. author: 包作者;
7. bin: 配置好 bin 字段后，将 NPM 包安装到全局，脚本会被添加到执行路径中，之后可以在命令行中直接执行;
8. main: `require()`引入包时，会优先检查此字段，并将其作为包中其余模块的入口;
9. scripts: 脚本说明对象，它主要被包管理器用来安装、编译、测试和卸载包;
10. engines: 支持 JavaScript 的引擎列表，有效的引擎取值包括 ejs、flusspferd、gpsee、jsc、spidermonkey、narwhal、node 和 v8;
11. dependencies: 使用当前包所需要依赖的包列表;
12. devDependencies: 开发模式时才需要依赖的包列表。

## <a name="href5">前后端共用模块</a> ##

Node.js 使得一些模块可以在前后端实现共用，但是在实际情况中，前后端的环境是略有差别的。浏览器的 JavaScript 需要经历从同一服务器端分发到多个客户端执行，其局限在于带宽，需要通过网络加载代码。服务器端 JavaScript 是相同的代码需要多次执行，其局限在于 CPU 和内存等资源，代码从磁盘中加载。

鉴于网络的原因，CommonJS 为后端 JavaScript 制定的规范并不完全适合前端的应用场景，后来，有两种前端模块规范诞生了，它们分别是 AMD 和 CMD，关于这两种规范的具体内容，请自行查阅资料，这里不加赘述。

---

```
ID         : 12
DATE       : 2019/04/06
AUTHER     : WJT20
TAG        : Node.js
```
