
# 深入浅出Node.js十一日探(一) #

## 目录 ##

1. [介绍](#href1)
2. [特点](#href2)
    1. [异步I/O](#href2-1)
    2. [事件与回调函数](#href2-2)
    3. [单线程](#href2-3)
    4. [跨平台](#href2-4)
3. [Node.js的应用场景](#href3)
    1. [I/O密集型](#href3-5)
    2. [是否不擅长CPU密集型业务](#href3-6)

## <a name="href1">介绍</a> ##

Node.js 是一个基于V8引擎、使用 JavaScript 作为开发语言的轻量级 Web 服务器，Node.js 具有基于事件驱动、非阻塞 I/O、单线程等特点，它强制不共享任何资源，包含十分适宜网络的库，为构建大型分布式应用程序提供基础设施，其目的是成为一个构建快速、可伸缩的网络应用平台。我们可以在 Node.js 基础上构建服务器、客户端、命令行工具等多种应用。

## <a name="href2">特点</a> ##

Node.js 使用 JavaScript 作为开发语言，保留了前端浏览器 JavaScript 中的大部分接口，并没有改写语言的任何特性，依旧基于作用域和原型链，它只是将前端中广泛运用的思想迁移到了服务器端。下面是 Node.js 相较其他语言的一些特点。

### <a name="href2-1">异步I/O</a> ###

在 Ajax 异步请求过程中，收到响应是在发送 Ajax 请求之后输出的，而收到响应的执行时间是不被预期的，但这不是什么问题，因为我们并不需要关注请求处理的内部流程，异步调用中对于结果值得捕获是注重结果，不关心过程的一种表现。

Node.js 中，异步 I/O 很常见，以读取文件信息为例，代码:

```js
fs.readFile(
    __dirname + '/test.txt',
    { flag: 'r+', encoding: 'utf8' },
    function (err, data) {
        if (err) {
            console.error(err);
        } else {
            console.log('success: ', data);
        }
    }
);
console.log('start');
```

读取文件信息是在读取文件完成之后输出的，读取文件完成的执行取决于读取文件的异步调用何时结束。

Node.js 底层构建了许多异步 I/O 的 API，这样的意义在于，在 Node.js 中，我们可以从语言层面很自然地进行并行 I/O 操作，每个调用之间无须等待之前地 I/O 调用结束，在编程模型上可以极大提升效率。

### <a name="href2-2">事件与回调函数</a> ###

Node.js 将前端浏览器中应用广泛且成熟地事件引入后端，配合异步 I/O，将事件暴露给业务逻辑。以下是监听终端输入内容的实例代码:

```js
process.stdin.setEncoding('utf8');
process.stdin.on('readable', function () {
    var chunk = process.stdin.read();
    console.log('input: ', chunk);
    process.exit();
});
```

我们设置了 readable 事件，只需将相关的业务逻辑写在执行完成的回调中。

使用事件编程有: 轻量级、松耦合、只关注事务点等，但需要注意，一旦存在大量异步任务，事件与事件之间各自独立，如何协作就变成一个棘手的问题。

Node.js 除了异步和事件外，回调函数也是一大特色，回调函数也是最好的接受异步调用返回数据的方法。这是因为在 JavaScript 中，函数作为一等公民，可以像对象一样传递给方法作为实参进行调用。异步编程中代码的编写顺序与执行顺序无关，对于习惯了同步编程的人来说，阅读这样的代码会有些吃力，所以需要先转换为异步编程思维，再去阅读、编写异步代码。

### <a name="href2-3">单线程</a> ###

JavaScript 在浏览器中是单线程的，Node.js 也保留了这一特点，也就是说，在 Node.js 中，JavaScript 与其他线程是无法共享任何状态的。

单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。

单线程的弱点具体有以下三方面:

1. 无法利用多核 CPU;
2. 错误会引起整个应用退出，应用的健壮性值得考虑;
3. 大量计算占用 CPU 导致无法继续调用异步 I/O。

在 Node.js 中，长时间的 CPU 占用会导致后续的异步 I/O 发不出调用，已完成的异步 I/O 的回调函数也会得不到及时执行。

Node.js 为了解决单线程中大计算量的问题，引入了子进程(child_process)，Node.js 通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这样可以很好地保持应用模型地简单和低依赖。子进程的出现，意味着 Node.js 可以从容地应对单线程在健壮性和无法利用多核 CPU 方向的问题。

### <a name="href2-4">跨平台</a> ###

Node.js 起初只能在 Linux 平台上运行，随着 Node.js 的发展，微软团队为其提供了 Windows 平台兼容方案，在 v0.6.0 版本发布时，Node.js 已经能够直接在 Windows 平台上运行了。

兼容 Windows 和 \*nix 平台主要得益于 Node.js 在架构层面的改动，它在操作系统与 Node.js 上层模块系统之间构建了一层平台层架构，即 libnv。目前，libnv 已经成为许多系统实现跨平台的基础组件。

## <a name="href3">Node.js的应用场景</a> ##

Node.js 的应用场景，离不开 I/O 密集型和 CPU 密集型这两种业务类型的讨论，接下来就来分析 Node.js 到底适合构建怎样的应用。

### <a name="href3-5">I/O密集型</a> ###

说 Node.js 擅长 I/O 密集型的应用场景，这基本上不会有人反对，原因就在于 Node.js 具有强大的事件循环处理能力，它不必启动每一个线程为每一个请求服务，资源占用极少。Node.js 面向网络且擅长并行 I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。

### <a name="href3-6">是否不擅长CPU密集型业务</a> ###

很多人质疑 Node.js 是否能胜任 CPU 密集的应用场景，实际上，V8的执行效率是十分高的，单从执行效率来做评判，V8的执行效率是毋庸置疑的。

但是 CPU 密集型应用带给 Node.js 的挑战还是有的，由于 JavaScript 单线程的原因，如果有长时间运行的计算(比如大循环)，将会导致 CPU 时间片不能释放，使得后续 I/O 无法发起。解决方法还是有的，那就是适时调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞 I/O 调用的发起，这样既能同时享受到并行异步 I/O 的好处，又能充分利用 CPU。

Node.js 虽然没有提供多线程用于计算支持，但是还是有以下两种方式来充分利用 CPU:

1. 通过编写 C/C++ 扩展的方式更高效地利用 CPU，将一些V8不能做到性能极致的地方通过 C/C++ 来实现;
2. 通过子进程的方式，将一部分 Node.js 进程当作常驻服务进程用于计算，然后利用进程间的消息来传递结果。

---

```
ID         : 117
DATE       : 2019/04/05
AUTHER     : WJT20
TAG        : Node.js
```
