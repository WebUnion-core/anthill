
# JavaScript设计模式重啃——设计原则 #

## 目录 ##

1. [单一职责原则(SRP)](#href1)
 [](#href2)   1. 定义
 [](#href3)   2. 注意点
 [](#href4)   3. 优缺点
2. [最少知识原则(LKP)](#href5)
3. [开放-封闭原则(OCP)](#href6)

## <a name="href1">单一职责原则(SRP)</a> ##

### <a name="href1-1">定义</a> ###

单一职责原则在 JavaScript 中的定义是，就一个对象和方法而言，应该仅有一个引起它变化的原因。职责的抽象含义是"引起变化的原因"，比方说，我们编写一个方法是基于两个动机，那么编写出来的方法就有两个职责，每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。

有多个职责构成的方法或对象通常是不稳定的，其内部多个职责耦合，特点是低内聚且脆弱。当我们需要修改其中的一个职责时，就必须小心翼翼，牵一发而动全身，稍有差错，将会造成意想不到的破坏。

总而言之，单一职责原则体现为：一个对象或方法只做一件事情。

### <a name="href1-2">注意点</a> ###

单一职责原则的应用难点就是如何去分离职责？应该在什么时候分离职责？

需要注意的一点是：并非所有的职责都要分离，如果两个职责总是同步变化，那么这两个职责就不需要分离，例如，发送 ajax 请求中，创建 xhr 对象和发送 xhr 请求就是同步变化的，这两个职责不需要分离。

另一个需要注意的点是，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经耦合在一起，但它们还没有发生改变的征兆，那么此时就没必要急着分离它们，在代码需要重构的时候再分离也不迟。换句话说，只要多个耦合职责没有变化的趋势，那么我们没有必要主动分离它们。

### <a name="href1-3">优缺点</a> ###

单一职责原则的优点是：降低了单个类或对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。把耦合且经常变化的职责分离出一个功能复杂的对象或方法，至少代码逻辑更清晰一些吧。

单一职责原则的缺点是：会明显增加编写代码的复杂度，单一职责原则虽然降低了一个类或对象的复杂度，但代码的复杂度也相应地提高了，假设我们将一个功能复杂度极高的对象中的职责分离出来，抽离出来的职责包含在一个粒度较小的对象或方法中，然而其内部又有许多职责，分离之后接着产生一个粒度更小的对象或方法，内部同样是一大堆的耦合变化职责......当我们要修改某个粒度极小的对象的职责时，你要一步一个追踪到那个对象，然后才能修改某个职责，这时你的头可能要炸了吧。简单来说就是，当我们按照职责把对象分解成更小的粒度之后，实际上也增大了这些对象之间相互耦合的难度。

## <a name="href2">最少知识原则(LKP)</a> ##

最少知识原则指的是一个软件实体应当尽可能少地与其他实体发生相互作用。软件实体是一个广义的概念，不仅包括对象，还包括系统、类、模块、函数、变量等。

最少知识原则要求我们在设计程序时，应当尽可能减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发起请求，可以通过第三者对象来转发这些对象。

## <a name="href3">开放-封闭原则(OCP)</a> ##

开放-封闭原则(OCP)是面向对象程序设计中最重要的一条原则，一个程序是否具有良好的设计往往体现在它是否符合开放-封闭原则。

开放-封闭原则的思想：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。相比于修改源程序，如果增加几行代码就能解决问题，那这显然更加简单和优雅，而且增加代码并不会影响原系统的稳定。

遵守开放-封闭原则，最明显的就是"封装变化"，即找出程序中将要发生变化的地方，然后把变化封装起来。通过封装变化的方式，可以把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，只需要替换那些容易发生变化的部分，如果这些部分是已经封装好的，那么替换起来也相对容易，而变化部分之外的就是稳定的部分，在系统的演变过程中，稳定的部分是不需要改变的。

---

```
ID         : 65
DATE       : 2018/01/28
AUTHER     : WJT20
TAG        : JavaScript
```
