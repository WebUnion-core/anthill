
# 算法见闻录——数据抽象 #

## 目录 ##

1. 抽象数据类型
    1. 使用抽象数据类型

## 抽象数据类型 ##

数据类型指的是一组值和一组对这些值的操作的集合，定义和使用数据类型的过程被称为数据抽象。

抽象数据类型(ADT)是一种能够对使用者隐藏数据表示的数据类型，抽象数据类型能将数据和函数实现关联，并将数据的表示方式隐藏起来，在使用抽象数据类型时，我们的注意力集中在API描述的操作上而不会去关心数据的表示；在实现抽象数据类型时，我们的注意力集中在数据本身并将实现对该数据的各种操作。

抽象数据类型支持封装，利用这个特点，我们可以:

1. 以适用于各种用途的API形式准确地定义问题；
2. 用API的实现描述算法和数据结构。

针对同一问题的不同算法实现的性能特点不同，抽象数据类型正适合于对算法的这种研究，因为它确保我们可以随时将算法性能的知识应用于实践中：可以在不修改任何用例代码的情况下用一种算法替换另一种算法并改进所有用例的性能。

### 使用抽象数据类型 ###

为演示抽象数据类型的使用，这里以一个简单的 Counter(计数器) 程序为例，首先设计一下API:

| public class Counter |                              |
| :------------------: | :--------------------------: |
| Counter(String id)   | 创建一个名为id的计数器         |
| void increment()     | 将计数器的值加1                |
| int tally()          | 该对象创建之后计数器被加1的次数 |
| String toString()    | 对象的字符串表示               |

我们并不关心 Counter 的内部的具体逻辑，只需要知道 Counter 类如何应用，以下用例代码中的 Flips 类使用了 Counter 类，它接受一个命令行参数T并模拟T次抛硬币:

```Java
public class Flips {
    public static void main(String[] args) {
        int T = Integer.parseInt(args[0]);

        // 创建两个不同的Counter对象，分别为正面朝上和背面朝上的计数器
        Counter heads = new Counter("head");
        Counter tails = new Counter("tails");

        for (int t = 0; t < T; t++) {
            // 借助StdRandom.bernoulli()模拟抛硬币事件
            if (StdRandom.bernoulli(0.5)) {
                // 正面朝上计数器叠加
                heads.increment();                
            } else {
                // 背面朝上计数器叠加
                tails.increment();
            }
        }

        // 分别打印计数器内容，输出的内容为toString()的返回值
        StdOut.println(heads);
        StdOut.println(tails);

        // 打印两个计数器差值
        int d = heads.tally() - tails.tally();
        StdOut.println("delta: " + Math.abs(d));
    }
}
```

输出内容:

```
% java Flips 10
7 heads
3 tails
delta: 4
```

以下是另一个使用 Counter 的用例代码，这次在程序中使用了数组，目的是模拟掷骰子:

```Java
public class Rolls {
    public static void main(String[] args) {
        int T = Integer.parseInt(args[0]);
        int SIDES = 6;
        Counter[] rolls = new Counter[SIDES + 1];

        // 创建6个计数器对象
        for (int i = 1; i <= SIDES; i++) {
            rolls[i] = new Counter(i + "'s");
        }

        for (int t = 0; t < T; t++) {
            // 借助StdRandom.uniform()生成大于等于1且小于7的随机数，以模拟掷骰子事件
            int result = StdRandom.uniform(1, SIDES + 1);

            // 叠加指定计数器
            rolls[result].increment();
        }

        // 遍历输出
        for (int i = 1; i <= SIDES; i++) {
            StdOut.println(rolls[i]);
        }
    }
}
```

输出内容:

```
% java Rolls 10
2 1's
1 2's
3 3's
1 4's
2 5's
1 6's
```

---

```
ARTICLE_ID : 122
POST_DATE : 2018/12/12
AUTHER : WJT20
```
