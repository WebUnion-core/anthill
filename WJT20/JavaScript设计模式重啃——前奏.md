
# JavaScript设计模式重啃——前奏 #

## 目录 ##

1. 动态类型语言和静态类型语言
    1. 动态类型语言
    2. 静态类型语言
2. 鸭子类型
3. 多态
4. 封装
    1. 封装数据
    2. 封装实现
    3. 封装类型
    4. 封装变化
5. JavaScript中的原型继承

---

## 动态类型语言和静态类型语言 ##

### 动态类型语言 ###

编程语言按数据类型可以分为：动态类型语言和静态类型语言。静态类型语言在编写代码时给变量定义明确的数据类型，而动态类型语言则无需明确定义变量的数据类型，因为只有在程序运行时、变量赋值后，这个变量才会具有某种类型。

动态类型语言的优点：编写的代码量更少，程序员可以更专注于逻辑表达，更利于阅读程序。

动态类型语言的缺点：无法保证变量类型，在程序的运行期可能发生跟类型相关的错误。

### 静态类型语言 ###

静态类型语言的优点：在编译时能及时发现类型不匹配的错误，可以在运行前发现数据类型错误并及时解决。编译器可以针对那些已明确类型的信息作出优化处理，大大提高程序的执行效率。

静态类型语言的缺点：迫使程序员确定变量的数据类型，这归根结底就是辅助我们编写高性能程序的手段而不是最终目的，类型的声明会增加额外的代码，将程序员的关注点从逻辑表达上移开。

---

## 鸭子类型 ##

鸭子类型的由来：“如果它走起来像鸭子，叫起来也是鸭子，那么它就是鸭子”。理解这句话了吗？简言之，鸭子类型指导我们只关注对象的行为，而不关注对象本身。

在动态类型语言的面向对象设计中，鸭子类型的概念至关重要，利用鸭子类型的思想，就能在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。书中举了两个例子：

1. 一个对象若有 push 和 pop 方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用；

2. 一个对象如果有 length 属性，也可以按照下标来存取属性(最好还有 slice 和 splice 等方法)，这个对象就可以被当作数组使用。

值得注意的是，在 JavaScript 中，“面向接口编程”的过程跟主流的静态类型语言不一样。

---

## 多态 ##

多态的定义：同一操作作用于不同的对象上，可以产生不同的解释和不同的执行结果。简单点说就是，给不同对象发送同一个信息，这些接受信息的对象会采取不同的策略去处理或反馈不同信息。

使用继承来得到多态效果，是让对象表现多态性的最常用的手段，继承通常包括实现继承和接口继承。

JavaScript 比较特殊，JavaScript 对象的多态性是与生俱来的，书中的解释是：JavaScript 作为一门动态类型语言，它在编译时没有类型检查的过程，既没有检查创建的对象类型，又没有检查传递的参数类型。

---

## 封装 ##

封装的目的是将信息隐藏，封装的内容包括：封装数据、封装实现、封装类型和封装变化。

### 封装数据 ###

将内部的变量私有化，外部作用域无法访问这些变量，通常使用闭包实现，示例代码如下：

```
var selfAnim = (function() {
    var timeSpan = 100;
    var count = 0;

    return {
        begin: function() {
            setInterval(function() {
                console.log(count++);
            }, timeSpan);
        }
    }
})();
selfAnim.begin();
```

### 封装实现 ###

从封装实现细节来讲，封装使得对象内部的变化对其他对象而言是不可见的，对象对它自己的行为负责，其他对象或者用户都不关心它的内部实现。封装使得对象之间的耦合变松散，对象之间只通过暴露的API接口来通信，当我们修改一个对象时，可以随意地修改它的内部实现，只要对外接口没有变化，就不会影响程序的其他功能。

### 封装类型 ###

封装类型针对的是静态类型语言，原理是通过抽象类和接口来进行，把对象的真正类型隐藏在抽象类或者接口之后，相比对象的类型，客户更关心对象的行为。

### 封装变化 ###

封装变化，可以把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易，这可以最大程度地保证程序的稳定性和可扩展性。

---

## JavaScript中的原型继承 ##

JavaScript 所遵守的原型编程的基本规则主要有以下这些：

1. 所有的数据都是对象；

2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它；

3. 对象会记住它的原型；

4. 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。

其实不能说 JavaScript 中的所有数据都是对象，但可以说绝大部分数据都是对象，所以 JavaScript 中有一个根对象，所有的对象都来源于这个根对象，这个根对象就是 Object.prototype 对象，然而这个对象是一个空的对象，其他所有的对象其实就是由它克隆而来。

在 JavaScript 中没有类的概念，然而我们可以使用 new 关键字创建一个实例对象，但是 new 关键字不是根据类来创建实例对象，而是根据一个叫作构造函数的东西。以以下代码为例：

```
function Person(name) {
    this.name = name;
}
var p1 = new Person("WJT20");
console.log(p1.name);
```

以上代码中，function 定义的不是一个普通的函数，这个函数用于产生实例对象，而不是用于专门处理某种逻辑，所以我们给它起了另一个名字——构造函数。

所谓“对象的原型”这种说法并不准确，准确的说法是，实例对象对应的构造函数有原型，而实例对象其实是把请求委托给它的构造函数的原型(这句话有点绕，需要用心理解)，所以，对于每个对象来说，它们至少要记住自己构造函数的原型是谁，要想知道它们对应的构造函数，我们可以访问它们的`__proto__`属性。

当一个对象无法响应某个请求的时候，它会顺着原型链把请求传递下去，直到遇到一个可以处理该请求的对象为止，JavaScript 的对象虽然都是由 Object.prototype 对象克隆而来，但是可以将原型动态指向其他对象，达到继承的效果，示例代码：

```
var obj = { count: 1 };
function Counter() {
    this.getCount = function() {
        console.log(this.count);
    }
}
Counter.prototype = obj;//改变原型指向，实现继承

var countObj = new Counter();
countObj.getCount();//输出：1
```

使用原型链时要注意，原型链并不是无限长的。当请求在原型链上一直传递，最后到 Object.prototype 上查找请求项时无果，接着继续从 Object.prototype 的原型上去找，然而 Object.prototype 已经是尽头，它的原型是 null，至此，请求终止。

---

```
ARTICLE_ID : 30
POST_DATE : 2017/09/09
RECENTLY_MODIFY : 2017/09/10
TIME_COUNTER : 1
AUTHER : WJT20
```
